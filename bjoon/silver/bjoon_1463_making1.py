# 핵심 아이디어는 dp 점화식
# 점화식이 핵심이다.
# dp는 규칙만 깨닫는다면 코드는 무척 짧다.

# dp에서 핵심은 dp[i]에서 i가 무엇을 뜻하는지를 잘 정해야한다.
'''
1. dp[i] = dp[i-1] + 1을 먼저 두는 이유

사실 이건 “항상 가능한 연산(-1)”을 기본값으로 설정하는 거야.

i를 i-1로 만드는 건 어떤 숫자에서든 항상 할 수 있으니까, 최소 연산 횟수 후보 중 하나로 넣어 두는 거지.

그리고 나서 “추가적으로 가능한 더 좋은 선택지(나누기)”가 있으면 갱신(min)하는 거야.

2. “나누기가 항상 더 낫다”는 보장이 없다

예시 들어볼게.

예시: 10

-1만 쓰면:
10 → 9 → 3 → 1 → 총 3번 나누기/빼기 = 3회

2로 나누면:
10 → 5 → 4 → 2 → 1 → 총 4회

즉, 단순히 2로 먼저 나누는 게 최적은 아니야.

예시: 6

-1 먼저 가면:
6 → 5 → 4 → 2 → 1 = 4회

3으로 나누면:
6 → 2 → 1 = 2회 (최적)

→ 케이스마다 다르다.

3. DP의 핵심

“순서를 미리 정해서 따라간다”가 아니라,

가능한 모든 후보 해( -1, /2, /3 )를 다 고려해서 그 중 최소를 고르는 게 DP야.

그래서 dp[i]는 항상 진짜 최소 횟수가 된다.

📌 DP를 잘 풀려면?

문제에서 반복되는 부분 구조 찾기

같은 계산이 여러 번 나오면 DP일 가능성 있음

상태 정의하기

dp[x] = 그 상태에서의 최적 값

점화식 세우기

dp[x] = min(dp[작은 문제들]) 같은 방식

기저 조건

가장 작은 입력값에 대한 답 정의
'''
N = int(input())
dp = [0] * (N+1)

for i in range(2, N+1):
    dp[i] = dp[i-1] + 1   # 1 빼는 경우
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)

print(dp[N])
